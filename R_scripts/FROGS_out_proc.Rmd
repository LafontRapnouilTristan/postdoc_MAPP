# FROGS output processing

```{r}
EcophyCofog::Library(c("EcophyCofog","metabaR","readr","dplyr","magrittr","ggplot2","reshape2","patchwork","ggpubr","tidyr","forcats","phyloseq","cowplot","readxl","microeco","file2meco","RColorBrewer","vegan"))
```


## prepare metabarlist


Load site metadata
```{r}
site_coordinates <- read.csv("../ressource/Site_edaphic_data/site_coord_MAPP.csv")  # get site coordinates
site_coordinates %<>% 
    mutate(Sample=ifelse(nchar(Sample)<3,paste0("0",Sample),Sample))%>% # reformat 1 into 001 and 64 to 064 etc...
    mutate(Sample=ifelse(nchar(Sample)<3,paste0("0",Sample),Sample))
site_coordinates %<>% 
    mutate(Sample=ifelse(grepl("^8",Sample),paste0("0",Sample),Sample)) # fix 87a and 87b to 087a and 087b
```


```{r}
path_frogs_out <- "../ressource/bioinfo_pipeline_FROGS/FROGS_galaxy_outputs/" # get path to my galaxy frogs outputs
folder_names <- list.files(path_frogs_out) # get file names
folder_names <- folder_names[1:3] # select the files of interests
data_set_colors <- c("aquamarine4","darkorange","darkorchid4")
names(data_set_colors) <- folder_names
boots_thshld <- 0.7 # define a RDP classifier bootstrap value under which we consider affiliation uncertain
metab_lists<- NULL
for(i in folder_names){
    
    data_temp <- read_delim(paste0(path_frogs_out,i,"/",i,"_tsv_out.tsv"), # read the tsv file
                            delim = "\t", escape_double = FALSE, 
                            trim_ws = TRUE)
    
    reads_frame <- t(as.matrix(data_temp[,colnames(data_temp)[grepl("L001",colnames(data_temp))]])) # extract site per otus reads count matrix
    colnames(reads_frame) <- data_temp$observation_name #set colnames as cluster ID (otu 'names')
    
    
    motus_frame <- data_temp[,colnames(data_temp)[!grepl("L001",colnames(data_temp))]] # extract motu information (taxonomy, counts etc)
    
    
    motus_frame %<>% dplyr::rename(sequence=seed_sequence) # rename seed_sequence columns to sequence
    motus_frame %<>% mutate(rdp_tax_and_bootstrap=paste0("k__",gsub("\\(|\\)","",gsub("d__|k__|unclassified;\\([0-9]+\\.[0-9]+\\);|_X+","",rdp_tax_and_bootstrap,perl=T)))) #also allows to use silva 23s databases if wanted but basically reformat taxonomy informations
    
    # depending on the dataset (and thus taxonomy databse used) we need to conduct different processes
    if(grepl(i,"23s")==T){ # for 23s
        motus_frame %<>% mutate(blast_taxonomy=ifelse(blast_taxonomy=="no data","d__;k__;p__;c__;o__;f__;g__;s__",blast_taxonomy)) # replace "no data" to explicitely empty taxonomic path in the blast taxonomy
        motus_frame %<>% separate(rdp_tax_and_bootstrap, # split rdp_taxonomy into a column per tax lvl
                                  into=c("Domain","boots_domain",
                                         "Kingdom","boots_Kingdom",
                                         "Phylum","boots_Phylum",
                                         "Class","boots_Class",
                                         "Order","boots_Order",
                                         "Family","boots_Family",
                                         "Genus","boots_Genus",
                                         "Species","boots_Species"),
                                  sep=";",
                                  remove = F)%>%
            separate(blast_taxonomy, # split blast taxonomy into a column per tax lvl
                     into=c("Kingdom_blast",
                            "Phylum_blast",
                            "Class_blast",
                            "Order_blast",
                            "Family_blast",
                            "Genus_blast",
                            "Species_blast"),
                     sep=";",
                     remove = F)%>%
            mutate(across(.cols=which(grepl("boots_",colnames(.))),.fns=as.numeric)) # set bootstraps as numeric
    }else{ # if 18s or 16s Kinda the same but with no "Domain" lvl
        motus_frame %<>% mutate(blast_taxonomy=ifelse(blast_taxonomy=="no data","k__;p__;c__;o__;f__;g__;s__",blast_taxonomy))
        motus_frame %<>% separate(rdp_tax_and_bootstrap,
                                  into=c("Kingdom","boots_Kingdom",
                                         "Phylum","boots_Phylum",
                                         "Class","boots_Class",
                                         "Order","boots_Order",
                                         "Family","boots_Family",
                                         "Genus","boots_Genus",
                                         "Species","boots_Species"),
                                  sep=";",
                                  remove = F)%>%
            separate(blast_taxonomy,
                     into=c("Kingdom_blast",
                            "Phylum_blast",
                            "Class_blast",
                            "Order_blast",
                            "Family_blast",
                            "Genus_blast",
                            "Species_blast"),
                     sep=";",
                     remove = F)%>%
            mutate(across(.cols=which(grepl("boots_",colnames(.))),.fns=as.numeric))
        
        
    }
    
    rownames(motus_frame) <- motus_frame$observation_name # use OTU names as rownames of the df
    pcr_frame <- data.frame(sample_id=colnames(data_temp)[grep("L001",colnames(data_temp))], type="sample",control_type=NA) # set pcr frame as required by metabaR
    rownames(pcr_frame) <- pcr_frame$sample_id # set rownames as site/sample id
    
    sample_frame <- data.frame(sample_id=colnames(data_temp)[grep("L001",colnames(data_temp))]) # create sample frame
    rownames(sample_frame) <- sample_frame$sample_id # set rownames as site/sample id
    
    metab_lists[[i]] <- metabarlist_generator(reads = reads_frame, # create metabarlist
                                              motus = motus_frame,
                                              pcrs = pcr_frame,
                                              samples = sample_frame
    )
    
    rm(data_temp,motus_frame,pcr_frame,reads_frame,sample_frame) # remove temporary files
}
```



## Start MetabaR processing


### Evaluate PCRs on sequencing depths

Plot number of OTUs and reads per PCRs as well as their correlation.
Correlation between reads and richness are problematic as they might indicate insufficient sequencing depth.
```{r}
diag_plots <- NULL
for (i in 1:length(folder_names)){
    data_temp <- metab_lists[[folder_names[i]]] # get one metabarlist
    
    # Compute the number of reads per pcr
    data_temp$pcrs$nb_reads <- rowSums(data_temp$reads)
    
    # Compute the number of motus per pcr
    data_temp$pcrs$nb_motus <- rowSums(data_temp$reads>0)
    
    # Overwrite with these new info
    metab_lists[[folder_names[i]]] <- data_temp
    
    check1 <- reshape2::melt(data_temp$pcrs[,c("control_type", "nb_reads", "nb_motus")])
    
    p1 <- ggplot(data <- check1, aes(x=control_type, y=value, color=control_type)) + 
        geom_boxplot() + 
        theme_bw() + 
        geom_jitter(alpha=0.2) + 
        scale_color_manual(values = c("brown", "red", "cyan4","pink"), na.value = "darkgrey") +
        facet_wrap(~variable, scales = "free_y") +
        ggtitle(folder_names[[i]])+ 
        theme(axis.text.x = element_text(angle=45, h=1),
              plot.title = element_text(face="bold"))
    
    p2 <-  ggplot(data_temp$pcrs, aes(x=nb_reads, y=nb_motus, color = control_type)) + 
        geom_point() + 
        theme_bw() + 
        scale_y_log10() + 
        scale_x_log10() + 
        scale_color_manual(values = c("brown", "red", "cyan4","pink"), na.value = "darkgrey")
    
    diag_plots[[folder_names[i]]] <- p1 + p2 + plot_layout(guides="collect")
    rm(p1,p2,data_temp,check1,data)
} 

diagplot <- ggarrange(plotlist = diag_plots, ncol = 1, nrow = length(diag_plots), common.legend = T, legend = "bottom")
```



Flag pcrs according to seq depths
```{r}
plot_seq_depth <- NULL
seq_depth_tab <- NULL
for (i in 1:length(folder_names)){
    
    data_temp <- metab_lists[[folder_names[i]]]
    plot_seq_depth[[folder_names[i]]] <-  ggplot(data_temp$pcrs, aes(nb_reads)) +
        geom_histogram(bins = 40, color="grey", fill="white") + 
        geom_vline(xintercept = 1e3, lty=2, color="orange") + # threshold
        scale_x_log10() + 
        labs(x="# Reads (with all MOTUs and PCRs)", 
             y="# PCRs") +
        theme_bw() +
        ggtitle(folder_names[[i]])+ 
        theme(panel.grid = element_blank(),
              plot.title = element_text(face="bold"))
    
    # Tag as ok pcrs with more than 3000 reads
    data_temp$pcrs$seqdepth_ok <- ifelse(data_temp$pcrs$nb_reads < 3e3, F, T)
    
    # Overwrite
    metab_lists[[folder_names[i]]] <- data_temp 
    
    # proportion of innaceptable pcrs seq depth, control excluded!!
    seq_depth_tab[[folder_names[i]]] <- table(data_temp$pcrs$seqdepth_ok[data_temp$pcrs$type=="sample"]) /
        nrow(data_temp$pcrs[data_temp$pcrs$type=="sample",])
    print(seq_depth_tab[[i]])
    rm(data_temp)
}
plotseqdepth <- ggarrange(plotlist =  plot_seq_depth, ncol = 1,nrow = length(folder_names)) #making sense whilst we have Non target?

```





### Evaluate PCRs on tagjump proportion

TAG jump slaying | Tough without controls. Pbly dont change it
```{r}
plot_tag_jump <- NULL
# Define a vector of thresholds to test
thresholds <- c(0,1e-4,1e-3, 1e-2, 3e-2, 5e-2) 


for (i in 1:length(folder_names)){
    
    data_temp <- metab_lists[[folder_names[i]]]
    rownames(data_temp$motus) <- colnames(data_temp$reads)
    
    
    # Run the tests and stores the results in a list
    tests <- lapply(thresholds, function(x) tagjumpslayer(data_temp,x))
    names(tests) <- paste("t_", thresholds, sep="")
    
    # Format the data for ggplot with amount of reads at each threshold
    tmp <- reshape2::melt(as.matrix(do.call("rbind", lapply(tests, function(x) rowSums(x$reads)))))
    colnames(tmp) <- c("threshold", "sample", "abundance")
    
    # Add richness in MOTUs at each threshold
    tmp$richness <-
        reshape2::melt(as.matrix(do.call("rbind", lapply(tests, function(x) {
            rowSums(x$reads > 0)
        }))))$value
    
    # Add control type information on pcrs and make data curation threshold numeric
    tmp$controls <- data_temp$pcrs$control_type[match(tmp$sample, rownames(data_temp$pcrs))]
    tmp$threshold <- as.numeric(gsub("t_", "", tmp$threshold))
    
    # New table formatting for ggplot
    tmp2 <- reshape2::melt(tmp, id.vars=colnames(tmp)[-grep("abundance|richness", colnames(tmp))])
    
    plot_tag_jump[[folder_names[i]]] <- ggplot(tmp2, aes(x=as.factor(threshold), y=value)) + 
        geom_boxplot(color="grey40") + 
        geom_vline(xintercept = which(levels(as.factor(tmp2$threshold)) == "0.01"), col="orange", lty=2) + 
        geom_jitter(aes(color=controls), width = 0.2, alpha=0.5) + 
        scale_color_manual(values = c("brown", "red", "cyan4","pink"), na.value = "darkgrey") +
        facet_wrap(~variable+controls, scale="free_y", ncol=4) + 
        theme_bw() + 
        scale_y_log10() +
        labs(x="OTU pcr : total abundance filtering threshold", y="# Reads/OTUs") +
        ggtitle(folder_names[[i]])+ 
        theme(panel.grid = element_blank(), 
              strip.background = element_blank(), 
              axis.text.x = element_text(angle=40, h=1), 
              legend.position = "none",
              plot.title = element_text(face="bold"))
    
    tests[["raw"]] <- data_temp
    metab_lists[[folder_names[i]]] <- tests 
    rm(data_temp,tmp,tmp2,tests)
}

plottagjump <- ggarrange(plotlist =  plot_tag_jump, ncol = 1,nrow = length(folder_names))

```



```{r}
chsn_thrshld <- rep("t_0")

for (i in 1:length(folder_names)){
    # Use tag-jump corrected metabarlist with the threshold identified above
    tmp <- metab_lists[[i]][[chsn_thrshld]]
    metab_lists[[i]] <- tmp
}
```


Get unique classes for 23s and 18s 

```{r}
class_18s <- unique(metab_lists$MAPP_18s$raw$motus$Class)
class_23s <- unique(metab_lists$MAPP_23s$raw$motus$Class)


order_18s <- unique(metab_lists$MAPP_18s$raw$motus$Order)
order_23s <- unique(metab_lists$MAPP_23s$raw$motus$Order)
```


### Remove non target OTUs

Tag non target OTUs
```{r}
non_target_prop <- NULL
non_targetconta_prop <- NULL

for (i in 1:length(folder_names)){
    
    data_temp <- metab_lists[[folder_names[i]]]
    
    target <- dplyr::last(BBmisc::explode(folder_names[i],"_")) # get current target
    
    if(target=="16s"){ # Keep all bac and archaea?
        #Flag MOTUs corresponding to target (TRUE) vs. non-target (FALSE) taxa 
        data_temp$motus$target_taxon <- grepl("Bacteria|Archaea", data_temp$motus$Kingdom)&!grepl("Chloroplast",data_temp$motus$Order)
        
        # Proportion of each of these over total number of MOTUs
        non_target_prop[[folder_names[i]]] <- table(data_temp$motus$target_taxon) / nrow(data_temp$motus)
        
        # Intersection with extraction contaminant flags (not contaminant = T)
        non_target_prop[[folder_names[i]]] <- table(data_temp$motus$target_taxon)
        print(non_target_prop[[i]])
    }else if(target=="18s"){ # 18s filter on order? 
        #Flag MOTUs corresponding to target (TRUE) vs. non-target (FALSE) taxa 
        data_temp$motus$target_taxon <- !grepl("Embryophyceae|Annelida|Arthropoda|Tardigrada|Cnidaria|Gastrotricha|Basidiomycota|Chytridiomycota|Ascomycota|Fungi|Mucoromycota|Microsporidiomycota", data_temp$motus$Order)
        
        # Proportion of each of these over total number of MOTUs
        non_target_prop[[folder_names[i]]] <- table(data_temp$motus$target_taxon) / nrow(data_temp$motus)
        
        # Intersection with extraction contaminant flags (not contaminant = T)
        non_target_prop[[folder_names[i]]] <- table(data_temp$motus$target_taxon)
        print(non_target_prop[[i]])
    }else{ # 23s filter on order?
        data_temp$motus$target_taxon <- !grepl("Embryophyceae|Embryophyta", data_temp$motus$Order)
        # Proportion of each of these over total number of MOTUs
        non_target_prop[[folder_names[i]]] <- table(data_temp$motus$target_taxon) / nrow(data_temp$motus)
        
        # Intersection with extraction contaminant flags (not contaminant = T)
        non_target_prop[[folder_names[i]]] <- table(data_temp$motus$target_taxon)
        print(non_target_prop[[i]])
    }
    
    
    # Overwrite
    metab_lists[[folder_names[i]]] <- data_temp
}
```


### Filter and format according to Assignment quality


Tag as poorly assigned Sequences with no assignment at the kingdom lvl (ie with RDP bootstrap values <70: boots_thshld choosen earlier) 
```{r}
plot_tax_boots <- NULL
# test <- NULL
for (i in 1:length(folder_names)){
    
    data_temp <- metab_lists[[folder_names[i]]]
    melty <- melt(data_temp$motus, id = c(colnames(data_temp$motus)[which(grepl("boots_",colnames(data_temp$motus))==F)] ))
    melty$variable <- gsub("boots_","",melty$variable)
    melty$variable <- as.factor(melty$variable)
    
    melty$variable <- fct_relevel(melty$variable,"Kingdom","Phylum","Class","Order","Family","Genus","Species")
    
    
    plot_tax_boots[[folder_names[i]]] <-  ggplot(melty,aes(x=variable,y=as.numeric(value))) +
        geom_boxplot(aes(fill=variable))+
        theme_bw()+
        ggtitle(folder_names[[i]])+
        labs(y="conf %")+
        theme(panel.grid.major.x = element_blank(),
              panel.grid.minor.x = element_blank(),
              axis.title.x = element_blank())+
        theme(legend.position = "n",
              plot.title = element_text(face = "bold"))
    
    # Create a "confident taxonomy" (boots >= boots_thshld)
    colnames_tmp <- c(gsub("boots_","",grep("boots_",colnames(data_temp$motus), value = T)))
    
    for(j in 1:length(colnames_tmp)){
        
        col <- match(colnames_tmp[j],colnames(data_temp$motus))
        a <- data_temp$motus[,c(col,col+1)]
        tax_lvl <- paste0(tolower(substr(names(a)[2],7,7)),"__")
        conf <- a %>% mutate(col_temp=ifelse(.[[2]]<boots_thshld,gsub(".*",tax_lvl,.[[1]],perl=T),.[[1]]))
        data_temp$motus <- cbind(data_temp$motus,conf[,3])
        colnames(data_temp$motus)[ncol(data_temp$motus)]<- paste0(colnames_tmp[j],"_conf_rdp")
    }
    
    # Tag sequences not assigned below Kingdom
    data_temp$motus %<>% mutate(good_assign = ifelse(Phylum_conf_rdp=="p__",F,T))
    
    # Overwrite
    # test[[folder_names[i]]] <- data_temp
    metab_lists[[folder_names[i]]] <- data_temp
    rm(data_temp,melty)
    
}

plottaxboots <- ggarrange(plotlist =  plot_tax_boots, ncol = 1,nrow = length(folder_names))
```





### Display noise in OTUs

summarize noise in motus
```{r}
# color_scale (create a common scale across datasets)
a <- unlist(combn(c("untargeted_taxon","poorly_assigned"),1,simplify = F))
b <- c("poorly_assigned|untargeted_taxon")
myColors <- RColorBrewer::brewer.pal(8,"Set1")
names(myColors) <- levels(as.factor(c(a,b,"not_artefactual")))
colScale <- scale_fill_manual(name = "grp",values = myColors, drop=F)


plot_noise_motu <- NULL
motu_noise_tab <- NULL
for (i in 1:length(folder_names)){
    
    data_temp <- metab_lists[[folder_names[i]]]
    
    # Create a table of MOTUs quality criteria 
    # noise is identified as FALSE in data_temp, the "!" transforms it to TRUE 
    motus.qual <- !data_temp$motus[,c("target_taxon","good_assign")] #not_degraded 
    colnames(motus.qual) <- c("untargeted_taxon","poorly_assigned") #degraded_seq  
    
    # Proportion of MOTUs potentially artifactual (TRUE) based on the criteria used
    motu_noise_tab[[folder_names[i]]]$motus <- prop.table(table(apply(motus.qual, 1, sum) > 0))
    
    # Corresponding proportion of artifactual reads (TRUE)
    motu_noise_tab[[folder_names[i]]]$reads <- prop.table(xtabs(data_temp$motus$observation_sum~apply(motus.qual, 1, sum) > 0))
    
    # Proportion of MOTUs and reads potentially artifactual for each criterion
    apply(motus.qual, 2, sum) / nrow(motus.qual)
    apply(motus.qual, 2, function(x) sum(data_temp$motus$observation_sum[x])/sum(data_temp$motus$observation_sum))
    
    tmp.motus <- 
        apply(sapply(1:ncol(motus.qual), function(x) {
            ifelse(motus.qual[,x]==T, colnames(motus.qual)[x], NA)}), 1, function(x) {
                paste(sort(unique(x)), collapse = "|")
            })
    tmp.motus <- as.data.frame(gsub("^$", "not_artefactual", tmp.motus))
    colnames(tmp.motus) <-  "artefact_type"
    tmp.motus %<>% mutate(artefact_type=as.factor(artefact_type)  )
    
    plot_noise_motu[[folder_names[i]]] <- ggplot(tmp.motus, aes(x=1, fill=artefact_type)) +
        geom_bar() +  xlim(0, 2) +
        labs(fill="Artifact type") + 
        coord_polar(theta="y") + theme_void() + 
        scale_fill_manual(name = "grp",values = myColors, drop=F) + 
        theme(legend.direction = "vertical") + 
        ggtitle(folder_names[i])+
        theme(plot.title = element_text(face="bold"))
    rm(tmp.motus,motus.qual,data_temp)
}
rm(myColors,colScale,a,b)

plotnoisemotu <- ggarrange(plotlist =  plot_noise_motu, ncol = 1,nrow = length(folder_names))
```




### Filter 


```{r}
cleaned_metablist <- NULL
summary_list <- NULL
sumpipeline_plots <- NULL
for (i in 1:length(folder_names)){ 
    # Use tag-jump corrected metabarlist with the threshold identified above
    tmp <- metab_lists[[i]]
    
    # Subset on MOTUs: we keep motus that are defined as TRUE following the 
    # criteria below (sum of x TRUE is equal to x with the rowSums function)
    row.names(tmp$motus) <- colnames(tmp$reads)
    
    tmp <- subset_metabarlist(tmp, "motus", 
                              indices = rowSums(tmp$motus[,c("good_assign", "target_taxon")]) == 2)# ?poorly assigned?
    
    # Subset on pcrs and keep only samples 
    data_temp <- subset_metabarlist(tmp, "pcrs", 
                                    indices = tmp$pcrs[,c("seqdepth_ok")] == TRUE & #, "replicating_pcr" 
                                        tmp$pcrs$type == "sample")
    
    #update counts and reads.    
    data_temp$motus$counts = colSums(data_temp$reads)
    data_temp$pcrs$reads_post = rowSums(data_temp$reads)
    data_temp$pcrs$motus_post = rowSums(ifelse(data_temp$reads>0, T, F))
    
    check <- melt(data_temp$pcrs[,c("nb_reads", "reads_post", 
                                    "nb_motus", "motus_post")])
    check$type <- ifelse(grepl("motus", check$variable), "richness", "abundance")
    
    
    
    summary_list[[folder_names[i]]] <- summary_metabarlist(data_temp)
    
    if(sum(colSums(data_temp$reads)==0)>0){print(paste0(folder_names[[i]]," empty motus present"))}
    if(sum(colSums(data_temp$reads)==0)>0){print(paste0(folder_names[[i]]," empty pcrs present"))}
    
    
    sumpipeline_plots[[folder_names[i]]] <- ggplot(data = check, aes(x = variable, y = value)) +
        geom_boxplot( color = "darkgrey") +
        geom_jitter(alpha=0.1, color = "darkgrey") +
        theme_bw() +
        facet_wrap(~type, scales = "free", ncol = 5) +
        theme(axis.text.x = element_text(angle=45, h=1),
              axis.title = element_blank()) +
        ggtitle(paste0(folder_names[i],"_",chsn_thrshld[i]))
    
    cleaned_metablist[[folder_names[i]]] <- data_temp
    rm(tmp,data_temp,check)
}
```



### Check effect of filter on reads and richness


```{r}
motu_read_plots_post <- NULL 
diag_plots_post <- NULL
for (i in 1:length(folder_names)){
    # Using the nb_reads and nb_motus defined previously in the data_temp$pcrs table
    data_temp <- cleaned_metablist[[i]]
    motu_read_plots_post[[folder_names[i]]] <- ggplot(data_temp$pcrs, aes(x=reads_post, y=motus_post, color = control_type)) + 
        geom_point() + theme_bw() + 
        scale_y_log10() + scale_x_log10() + 
        scale_color_manual(values = c("brown", "red", "cyan4","pink"), na.value = "darkgrey")+
        ggtitle(folder_names[[i]])+
        theme(plot.title = element_text(face="bold"))+
        geom_smooth(method="lm",color="darkorange")
    
    check1 <- reshape2::melt(data_temp$pcrs[,c("control_type", "reads_post", "motus_post")])
    
    p1 <- ggplot(data <- check1, aes(x=control_type, y=value, color=control_type)) + 
        geom_boxplot() + 
        theme_bw() + 
        geom_jitter(alpha=0.2) + 
        scale_color_manual(values = c("brown", "red", "cyan4","pink"), na.value = "darkgrey") +
        facet_wrap(~variable, scales = "free_y") +
        ggtitle(folder_names[[i]])+ 
        theme(axis.text.x = element_text(angle=45, h=1),
              plot.title = element_text(face="bold"))
    
    p2 <-  ggplot(data_temp$pcrs, aes(x=reads_post, y=motus_post, color = control_type)) + 
        geom_point() + 
        theme_bw() + 
        scale_y_log10() + 
        scale_x_log10() + 
        scale_color_manual(values = c("brown", "red", "cyan4","pink"), na.value = "darkgrey")+
        geom_smooth(method="lm",color="darkorange")
    
    diag_plots_post[[folder_names[i]]] <- p1 + p2 + plot_layout(guides="collect")
    rm(p1,p2,data_temp,check1,data)
}


motureadplotspost <- ggarrange(plotlist = motu_read_plots_post,ncol=1,nrow=length(folder_names))
diagplotpost <- ggarrange(plotlist = diag_plots_post,ncol=1,nrow=length(folder_names))
ggsave("../Figures/motu_reads_cor.png",diagplotpost)
```


OK we have strong correlation between richness and reads within samples (deseq2 or rarefaction?)
Will depend on questions (test link between bioclimatic/geographical variables and the number of reads)
Differential abundance implementation in this models.




## Start data wrangling

### Transform to physeq lists


```{r}
physeqlists <- NULL
raw_physeqlists <- NULL
for (i in 1:length(folder_names)){
    data_temp_cleaned <- cleaned_metablist[[i]] 
    data_temp <- metab_lists[[folder_names[i]]]
    
    rownames(data_temp$motus) <- colnames(data_temp$reads)
    # Get row data only for samples
    tmp <- subset_metabarlist(data_temp, table = "pcrs",
                              indices = data_temp$pcrs$type == "sample")
    
    tmpcl <- subset_metabarlist(data_temp_cleaned, table = "pcrs",
                                indices = data_temp_cleaned$pcrs$type == "sample")
    
    # Format for phyloseq
    
    otumat <- as.matrix(tmp$reads)
    taxmat <- as.matrix(tmp$motus)
    sammat <- left_join(tmp$samples,tmp$pcrs)
    OTU <- otu_table(otumat, taxa_are_rows = F)
    TAX <- tax_table(taxmat)
    SAM <- sample_data(sammat)
    rownames(SAM) <- SAM$sample_id
    physeq <- phyloseq(OTU,TAX,SAM)
    raw_physeqlists[[folder_names[i]]] <-  physeq
    
    otumatcl <- as.matrix(tmpcl$reads)
    taxmatcl <- as.matrix(tmpcl$motus)
    sammatcl <- left_join(tmpcl$samples,tmpcl$pcrs)
    OTUcl <- otu_table(otumatcl, taxa_are_rows = F)
    TAXcl <- tax_table(taxmatcl)
    SAMcl <- sample_data(sammatcl)
    rownames(SAMcl) <- SAMcl$sample_id
    physeqcl <- phyloseq(OTUcl,TAXcl,SAMcl)
    
    physeqlists[[folder_names[i]]] <-  physeqcl
    rm(data_temp_cleaned,data_temp,tmp,tmpcl,otumat,taxmat,sammat,OTU,TAX,SAM,physeq,otumatcl,taxmatcl,sammatcl,OTUcl,TAXcl,SAMcl,physeqcl)
}
```


remove unwanted samples


```{r}
for (i in 1:length(folder_names)){
    data_temp <- physeqlists[[folder_names[i]]]
    data_temp@sam_data$reads_post <- rowSums(data_temp@otu_table)
    
    data_temp@sam_data$reads_post = rowSums(data_temp@otu_table) # reads per samples
    data_temp@sam_data$motus_post = rowSums(ifelse(data_temp@otu_table>0, T, F)) # motus per samples
    
    
    physeqlists[[folder_names[i]]] <- subset_samples(data_temp, !grepl("23[1-7]|239|240|241",data_temp@sam_data$sample_id))
}

```


### Transform to microeco

```{r}
meco_18s <- phyloseq2meco(physeqlists$MAPP_18s)
meco_23s <- phyloseq2meco(physeqlists$MAPP_23s)
meco_16s <- phyloseq2meco(physeqlists$MAPP_16s)
```

```{r}
meco_18s$sample_table %<>% mutate(Sample = gsub("[A-Z]|-|(?=_).*","",sample_id,perl = T)) # reformat sample Id
meco_16s$sample_table %<>% mutate(Sample = gsub("[A-Z]|-|(?=_).*","",sample_id,perl = T))
meco_23s$sample_table %<>% mutate(Sample = gsub("[A-Z]|-|(?=_).*","",sample_id,perl = T))



meco_18s$sample_table %<>% mutate(Sample = ifelse(nchar(Sample)<3,paste0("0",Sample),Sample)) # 18s lacks 0s before samples <100 (eg 19 instead of 019 or 1 for 001)

meco_23s$sample_table$Sample[which(meco_23s$sample_table$Sample=="205")] <- "203"# for 23s 205 is 203

setdiff(meco_16s$sample_table$Sample,meco_18s$sample_table$Sample) # check differences between the sites present in the different datasets
setdiff(meco_16s$sample_table$Sample,meco_23s$sample_table$Sample)
setdiff(meco_18s$sample_table$Sample,meco_23s$sample_table$Sample)

# 16s has 042047 an 047042 that will pbly be removed because of mixture during pcr. 87a and 87b are replicate for 87 in 18s and 23s datasets


# check for diff between sites coordinates obtained form vicent and samples remaining in the final analysis

setdiff(site_coordinates$Sample,meco_16s$sample_table$Sample) # we willingly removed 231-7|239|240|241 / 042 and 047 are mixed up what about : 115/124/199/200/201/205/206/208/209/227/252/253/258
setdiff(site_coordinates$Sample,meco_18s$sample_table$Sample) # we willingly removed 231-7|239|240|241 / what about : 115/199/200/201/205/206/207/208/209/227/252/253/254/258

setdiff(site_coordinates$Sample,meco_23s$sample_table$Sample) # we willingly removed 231-7|239|240|241 / what about : 115/199/200/201/205/206/207/208/209/227/252/253/254/258

setdiff(meco_16s$sample_table$Sample,site_coordinates$Sample) # we willingly removed 231-7|239|240|241 / 042 and 047 are mixed up what about : 115/124/199/200/201/205/206/208/209/227/252/253/258
setdiff(meco_18s$sample_table$Sample,site_coordinates$Sample) # we willingly removed 231-7|239|240|241 / what about : 115/199/200/201/205/206/207/208/209/227/252/253/254/258

setdiff(meco_23s$sample_table$Sample,site_coordinates$Sample) # 116 119 and 166 are samples for which we have no metadata




meco_18s$sample_table %<>% left_join(site_coordinates) # add coordinates to the three datasets
meco_16s$sample_table %<>% left_join(site_coordinates)
meco_23s$sample_table %<>% left_join(site_coordinates)


rownames(meco_23s$sample_table) <- meco_23s$sample_table$sample_id # reset rownames
rownames(meco_18s$sample_table) <- meco_18s$sample_table$sample_id
rownames(meco_16s$sample_table) <- meco_16s$sample_table$sample_id

meco_16s$tidy_dataset() #tidy datasets
meco_18s$tidy_dataset()
meco_23s$tidy_dataset()

# Compute the number of reads per pcr
meco_16s$sample_table$nb_reads <- colSums(meco_16s$otu_table)
meco_18s$sample_table$nb_reads <- colSums(meco_18s$otu_table)
meco_23s$sample_table$nb_reads <- colSums(meco_23s$otu_table)

# Compute the number of motus per pcr
meco_16s$sample_table$nb_reads <- colSums(meco_16s$otu_table>0)
meco_18s$sample_table$nb_reads <- colSums(meco_18s$otu_table>0)
meco_23s$sample_table$nb_reads <- colSums(meco_23s$otu_table>0)


gc()
```

### Rarefaction Curves
```{r}
# 16s ##

tab16s <- t(otu_table(file2meco::meco2phyloseq(meco_16s))) # get the community
class(tab16s) <- "matrix" # change class
curve16s <- rarecurve(tab16s) # use vegan rarefaction curves
names(curve16s) <- rownames(tab16s) # name curves after sample IDs

# Coerce data into "long" form.
protox <- mapply(FUN = function(x, y) {
    mydf <- as.data.frame(x)
    colnames(mydf) <- "value"
    mydf$samples <- y
    mydf$subsample <- attr(x, "Subsample")
    mydf
}, x = curve16s, y = as.list(names(curve16s)), SIMPLIFY = FALSE)

xy <- do.call(rbind, protox)
rownames(xy) <- NULL  # pretty

# Plot.
rare16s <- ggplot(xy, aes(x = subsample, y = value, group = samples )) +
    theme_bw() +
    scale_color_discrete(guide = "none") +  # turn legend on or off
    geom_line(color = "aquamarine4")+
    xlab("nb reads")+
    ylab("OTUs count")

# 18s ##

tab18s <- t(otu_table(file2meco::meco2phyloseq(meco_18s)))
class(tab18s) <- "matrix"
curve18s <- rarecurve(tab18s)
names(curve18s) <- rownames(tab18s)

# Coerce data into "long" form.
protox <- mapply(FUN = function(x, y) {
    mydf <- as.data.frame(x)
    colnames(mydf) <- "value"
    mydf$samples <- y
    mydf$subsample <- attr(x, "Subsample")
    mydf
}, x = curve18s, y = as.list(names(curve18s)), SIMPLIFY = FALSE)

xy <- do.call(rbind, protox)
rownames(xy) <- NULL  # pretty

# Plot.
rare18s <- ggplot(xy, aes(x = subsample, y = value, group = samples )) +
    theme_bw() +
    scale_color_discrete(guide = "none") +  # turn legend on or off
    geom_line(color = "darkorange")+
    xlab("nb reads")+
    ylab("OTUs count")

# 23s ##

tab23s <- t(otu_table(file2meco::meco2phyloseq(meco_23s)))
class(tab23s) <- "matrix"
curve23s <- rarecurve(tab23s)
names(curve23s) <- rownames(tab23s)

# Coerce data into "long" form.
protox <- mapply(FUN = function(x, y) {
    mydf <- as.data.frame(x)
    colnames(mydf) <- "value"
    mydf$samples <- y
    mydf$subsample <- attr(x, "Subsample")
    mydf
}, x = curve23s, y = as.list(names(curve23s)), SIMPLIFY = FALSE)

xy <- do.call(rbind, protox)
rownames(xy) <- NULL  # pretty

# Plot.
rare23s <- ggplot(xy, aes(x = subsample, y = value, group = samples )) +
    theme_bw() +
    scale_color_discrete(guide = "none") +  # turn legend on or off
    geom_line(color = "darkorchid4")+
    xlab("nb reads")+
    ylab("OTUs count")


# Name, combine and save plots

rare16s <- rare16s+
    ggtitle("MAPP_16s")+
    theme(plot.title = element_text(face='bold'))

rare18s <- rare18s+
    ggtitle("MAPP_18s")+
    theme(plot.title = element_text(face='bold'))

rare23s <- rare23s+
    ggtitle("MAPP_23s")+
    theme(plot.title = element_text(face='bold'))
ggsave("../Figures/rarefaction_curves.png",rare16s/rare18s/rare23s)
```

## Investigate singletons

Visualize number of singletons
```{r}
single_frame <- NULL # prime frame
for(i in folder_names){
    data_temp <- get(paste0("meco_",gsub("MAPP_","",i))) # get data

    n_single_otu <- sum(rowSums(data_temp$otu_table)==1) # number of single otus (those that are present exactly once across all sites)
    n_non_single_otu <- sum(rowSums(data_temp$otu_table)>1) # number of non single otu
    n_single_reads <- sum(data_temp$otu_table[which(rowSums(data_temp$otu_table)==1),]) # number of reads from the data set that correspond to OTU singletons (sum of reads on singletons subset)
    n_non_single_reads <- sum(data_temp$otu_table[which(rowSums(data_temp$otu_table)>1),]) # same but for non singletons
    df_tmp <- data.frame(data_set=gsub("MAPP_","",i), # create a dataframe with these info
                         otu_val=c(n_single_otu,n_non_single_otu),
                         read_val=c(n_single_reads,n_non_single_reads),
                         type=c("n_single","n_non_single"))
    df_tmp %<>% mutate(pct_otus=otu_val/sum(otu_val), # convert to %
                       pct_reads=read_val/sum(data_temp$otu_table))
    single_frame <- rbind(single_frame,df_tmp) # update frame
}

plot_singletons_reads <- ggplot(single_frame,aes(x = data_set,y = pct_reads, fill=type))+
    geom_bar(position="stack",stat = "identity")+
    theme_classic2()+
    scale_fill_manual(values = c("lightblue","lightgreen"))+
    ggtitle("Pct of singletons reads")+
    theme(plot.title = element_text(face='bold'))

plot_singletons_otus <-  ggplot(single_frame,aes(x = data_set,y = pct_otus, fill=type))+
    geom_bar(position="stack",stat = "identity")+
    theme_classic2()+
    scale_fill_manual(values = c("lightseagreen","mediumvioletred"))+
    ggtitle("Pct of singletons otus")+
    theme(plot.title = element_text(face='bold'))

plot_singletons <- plot_singletons_reads/plot_singletons_otus

ggsave("../Figures/singletons.png",plot_singletons)
```

We have only singletons in 16s but ~80% of our OTUs but ~4% of our reads.
Can this be interpretated as high endemism in peatlands bacteria??
And loads of rare strains? 
We are working at low resolution with SWARM clustering, increasing singletons.
We use the 'fastidious' option that should prevent to many singletons if they are close https://peerj.com/articles/1420/
Is it legit to have that many singletons?


Can't remove that many OTUs,huge effect on alpha div no?
Tho quite well distributed across samples.
Should reduce divergence between my samples.

Shall we keep singletons for alpha div and stuff but aggregate at some phylogenetical levels for modeling approaches? 
Hypothesis that phylogeny retains ecological features but is it true for bacteria? 




sample alpha div
```{r}
alpha_plot_list <- NULL # prime plot list
for(i in folder_names){
    data_temp <- get(paste0("meco_",gsub("MAPP_","",i))) # get data
    
    alpha <- colSums(data_temp$otu_table!=0) # sample alpha diversity as the number of non null rows (otus)
    single_otu <-  colSums(filter(data_temp$otu_table,rowSums(data_temp$otu_table)==1)==1) # number of singletons otus within sample as the number of otus restricted to this sample (subset rowsums) and with one read (==1)
    # non_single_otu2 <- colSums(data_temp$otu_table>1)
    non_single_otu <- alpha-single_otu # OTUs that might be singletons within the sample but not the dataset 
    df_tmp <- data.frame(data_set=gsub("MAPP_","",i),value = 
                             c(rbind(single_otu,non_single_otu)),type=c("single_otu","non_single_otu"),sample=rep(1:ncol(data_temp$otu_table),each=2))
    alpha_plot_list[[i]] <-{ggplot(df_tmp,aes(x=sample,y=value,fill=type))+
            geom_bar(stat="identity",position = "stack")+
            theme_classic2()+
            ggtitle(i)+
            theme(plot.title = element_text(face='bold'))+
            xlab("samples_row")+
            scale_fill_manual(values=c("lightseagreen","mediumvioletred"))} 
}

plot_alpha <- alpha_plot_list$MAPP_16s/alpha_plot_list$MAPP_18s/alpha_plot_list$MAPP_23s
ggsave(plot_alpha,filename="../Figures/plot_alpha_ratio.png")

# Just for 16s i want to compute alpha div if I remove true singletons

alpha <- colSums(meco_16s$otu_table!=0)
single_otu <-  colSums(filter(meco_16s$otu_table,rowSums(meco_16s$otu_table)==1)==1)
non_single_otu <- alpha-single_otu
df_tmp <- data.frame(value = non_single_otu,
                     sample=1:ncol(meco_16s$otu_table))
ggsave(ggplot(df_tmp,aes(x=sample,y=value))+
           geom_bar(stat="identity",fill="aquamarine4")+
           theme_classic2()+
           ggtitle("MAPP_16s non singletons alphadiversity")+
           theme(plot.title = element_text(face='bold'))+
           xlab("samples_row"),
       filename = "../Figures/plot_alpha_no_true_singletons_16s.png")

alpha <- colSums(meco_16s$otu_table!=0)
single_otu <-  colSums(meco_16s$otu_table==1)
non_single_otu <- alpha-single_otu
df_tmp <- data.frame(value = non_single_otu,
                     sample=1:ncol(meco_16s$otu_table))
ggsave(ggplot(df_tmp,aes(x=sample,y=value))+
           geom_bar(stat="identity",fill="aquamarine4")+
           theme_classic2()+
           ggtitle("MAPP_16s non singletons alphadiversity")+
           theme(plot.title = element_text(face='bold'))+
           xlab("samples_row"),
       filename = "../Figures/plot_alpha_no_sample_singletons_16s.png")

# alpha div for all datasets

alpha_plot_list <- NULL
for(i in folder_names){
    data_temp <- get(paste0("meco_",gsub("MAPP_","",i)))
    
    alpha <- colSums(data_temp$otu_table!=0)
    df_tmp <- data.frame(data_set=gsub("MAPP_","",i),alpha=alpha)
    alpha_plot_list[[i]] <-{ggplot(df_tmp,aes(x=1:nrow(df_tmp),y=alpha))+
            geom_bar(stat="identity",fill=data_set_colors[i])+
            theme_classic2()+
            ggtitle(i)+
            theme(plot.title = element_text(face='bold'))+
            xlab("samples_row")} 
}

plot_alpha <- alpha_plot_list$MAPP_16s/alpha_plot_list$MAPP_18s/alpha_plot_list$MAPP_23s
ggsave(plot_alpha,filename="../Figures/plot_alpha.png")
```


## Investigate depths

```{r}
depth_plot_list <- NULL
for(i in folder_names){
    data_temp <- get(paste0("meco_",gsub("MAPP_","",i)))
    
    seq_depths <- colSums(data_temp$otu_table)
    df_tmp <- data.frame(data_set=gsub("MAPP_","",i),seq_depths=seq_depths)
    depth_plot_list[[i]] <-{ggplot(df_tmp,aes(seq_depths))+
            geom_histogram(bins = 40,fill = data_set_colors[i])+
            theme_classic2()+
            ggtitle(i)+
            theme(plot.title = element_text(face='bold'))+
            scale_x_log10()+
            geom_vline(xintercept = 1e3, lty=2, color="black")} 
}

plot_depths <- depth_plot_list$MAPP_16s/depth_plot_list$MAPP_18s/depth_plot_list$MAPP_23s
ggsave(plot_depths,filename="../Figures/plot_depths.png")

# Just for 16s i want to compute seq depths if I remove true singletons not changing a lot as singletons!!

reads <- colSums(filter(meco_16s$otu_table,rowSums(meco_16s$otu_table)!=1))
df_tmp <- data.frame(reads,
                     sample=1:ncol(meco_16s$otu_table))
ggsave(ggplot(df_tmp,aes(reads))+
    geom_histogram(bins=40,fill="aquamarine4")+
    theme_classic2()+
    ggtitle("MAPP_16s no true singletons seqdepths")+
    theme(plot.title = element_text(face='bold'))+
    scale_x_log10()+
    geom_vline(xintercept = 1e3, lty=2, color="black")+
    xlab("seq_depths"),
filename= "../Figures/plot_depths_no_true_singletons_16s.png")
```


 ## Clean and save ENV

```{r}
param_list <- list(boots_thshld=boots_thshld,
                   chsn_thrshld=chsn_thrshld,
                   path_frogs_out=path_frogs_out,
                   thresholds=thresholds)

save(curve16s,curve18s,curve23s, file = "../output/rare_cuves.Rdata")
save(param_list, file = "../output/clean_frogs_param.Rdata")
save(metab_lists,cleaned_metablist,file = "../output/metabarlists.Rdata")
save(physeqlists,raw_physeqlists,file = "../output/physeqlists.Rdata")
save(meco_16s,meco_18s,meco_23s, file = "../output/microeco_obj.Rdata")

to_keep <- c("metab_lists","cleaned_metablist","physeqlists","raw_physeqlists","meco_16s","meco_18s","meco_23s")
rm(list=setdiff(ls(), to_keep))
```









